"""
Lerp â€” Snap Engine (Stage 3b)
==============================
The core technical differentiator.

Takes bloated vtracer SVG output and rewrites it using clean geometric
primitives (<circle>, <rect>, <polygon>) instead of opaque <path> data.

This is where an LLM's understanding of SVG *semantics* fixes what a
pixel-level tracer gets mathematically right but aesthetically wrong.

Two-pass approach:
  Pass 1: Feed SVG code â†’ path simplification + primitive recognition
  Pass 2: Render screenshot + SVG code â†’ visual + code reasoning for refinement
"""

import json
import base64
import subprocess
from pathlib import Path
from dataclasses import dataclass
from anthropic import Anthropic

import sys
sys.path.insert(0, str(Path(__file__).parent.parent.parent))
from config.settings import ANTHROPIC_API_KEY, SNAP_ENGINE_MODEL, OUTPUT_DIR


@dataclass
class SnapResult:
    """Result from the snap engine cleanup."""
    input_svg_path: Path
    cleaned_svg_path: Path
    input_nodes: int
    output_nodes: int
    input_size_bytes: int
    output_size_bytes: int
    node_reduction_pct: float
    size_reduction_pct: float
    primitives_used: list[str]   # e.g., ["circle", "rect", "polygon"]


# â”€â”€â”€ Prompts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

SNAP_PASS1_SYSTEM = """You are the Snap Engine â€” a specialized SVG code optimizer for logo vectorization.

You receive SVG code that was generated by an automated tracer (vtracer). The tracer produces
mathematically literal paths with too many anchor points, jittery curves, and no understanding
of geometric intent.

Your job: Rewrite the SVG using clean geometric primitives.

## Rules â€” The Primitive Library

Apply these recognition rules in order:

1. **Circle detection:** If a closed path approximates a circular arc with >95% fit,
   replace it with `<circle cx="" cy="" r=""/>` or `<ellipse>`.

2. **Rectangle detection:** If a closed path has 4 corners within 3% of right angles,
   replace with `<rect x="" y="" width="" height=""/>`.

3. **Polygon detection:** If a closed path is made of straight line segments,
   replace with `<polygon points=""/>`.

4. **Line detection:** If a line segment is within 2Â° of horizontal/vertical,
   snap to `<line>` with exact coordinates, or use `h`/`v` commands in path.

5. **Symmetry enforcement:** If the shape has bilateral symmetry,
   enforce it: `x_right = viewBox_width - x_left`.

6. **Coordinate snapping:** Round ALL coordinates to whole numbers.

7. **Node minimization:** A circle needs 4 Bezier nodes max, not 40.
   Collapse redundant points that lie on the same curve.

## Output Rules

- Preserve the original viewBox dimensions
- Preserve fill colors exactly (hex codes)
- Keep background rect if present
- Output valid SVG with proper xmlns
- Use semantic elements: <circle>, <rect>, <polygon>, <line>, <polyline>
- Only use <path> for genuinely complex organic curves
- Include brief XML comments describing each shape (e.g., <!-- Left eye -->)
- Output ONLY the SVG code â€” no markdown, no explanation

## Quality Targets

- Total nodes: < 50 for simple marks, < 100 for complex ones
- File size: < 2KB for simple marks, < 5KB for complex ones
- Geometric accuracy: circles must be actual <circle> elements
- Symmetry: bilateral symmetry enforced within 1px"""


SNAP_PASS2_SYSTEM = """You are the Snap Engine performing visual refinement on a cleaned SVG logo.

You will receive:
1. The SVG code from your first cleanup pass
2. A rendered screenshot of that SVG

Your job: Identify what's still geometrically off and fix it.

Look for:
- Lopsided curves or asymmetry
- Circles that aren't perfectly circular
- Lines that should be straight but aren't
- Shapes that don't align with each other
- Visual balance issues
- Elements that are too close or too far apart

Output the corrected SVG code only â€” no explanation, no markdown."""


class SnapEngine:
    """
    LLM-powered SVG cleanup engine.
    
    Usage:
        snap = SnapEngine()
        result = snap.clean("traced_logo.svg")
        # result.cleaned_svg_path â†’ production-quality SVG
        
        # With visual refinement (requires cairosvg):
        result = snap.clean("traced_logo.svg", visual_pass=True)
    """

    def __init__(self, api_key: str = None):
        self.client = Anthropic(api_key=api_key or ANTHROPIC_API_KEY)
        self.model = SNAP_ENGINE_MODEL
        self.output_dir = OUTPUT_DIR / "cleaned"
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def clean(self, svg_path: Path | str, name: str = None,
              visual_pass: bool = False, design_context: str = "") -> SnapResult:
        """
        Run the snap engine on a traced SVG.
        
        Args:
            svg_path: Path to the vtracer + SVGO output
            name: Base name for output file
            visual_pass: Whether to do Pass 2 (visual refinement)
            design_context: Optional context about what the logo represents
            
        Returns:
            SnapResult with metrics comparing before/after
        """
        svg_path = Path(svg_path)
        name = name or svg_path.stem.replace("_optimized", "").replace("_raw", "")

        svg_code = svg_path.read_text()
        input_size = len(svg_code.encode())

        # â”€â”€ Pass 1: Code-based cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        context_note = ""
        if design_context:
            context_note = f"\n\nContext about this logo: {design_context}"

        cleaned_code = self._pass1_code_cleanup(svg_code, context_note)

        # â”€â”€ Pass 2: Visual refinement (optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        if visual_pass:
            try:
                cleaned_code = self._pass2_visual_refinement(cleaned_code, name)
            except Exception as e:
                print(f"  âš ï¸ Visual pass failed (using Pass 1 output): {e}")

        # â”€â”€ Final SVGO pass â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        output_path = self.output_dir / f"{name}_snapped.svg"
        output_path.write_text(cleaned_code)

        # Run SVGO on the cleaned output for final optimization
        final_path = self.output_dir / f"{name}_final.svg"
        try:
            subprocess.run(
                ["svgo", str(output_path), "-o", str(final_path), "--multipass"],
                capture_output=True, text=True,
            )
            if final_path.exists():
                cleaned_code = final_path.read_text()
                output_path = final_path
        except Exception:
            pass  # Skip if SVGO fails, use pre-SVGO output

        # â”€â”€ Metrics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        output_size = len(cleaned_code.encode())
        input_nodes = self._count_nodes(svg_code)
        output_nodes = self._count_nodes(cleaned_code)

        return SnapResult(
            input_svg_path=svg_path,
            cleaned_svg_path=output_path,
            input_nodes=input_nodes,
            output_nodes=output_nodes,
            input_size_bytes=input_size,
            output_size_bytes=output_size,
            node_reduction_pct=round((1 - output_nodes / max(input_nodes, 1)) * 100, 1),
            size_reduction_pct=round((1 - output_size / max(input_size, 1)) * 100, 1),
            primitives_used=self._detect_primitives(cleaned_code),
        )

    def _pass1_code_cleanup(self, svg_code: str, context: str = "") -> str:
        """Pass 1: Pure code analysis â€” recognize shapes, snap to primitives."""
        response = self.client.messages.create(
            model=self.model,
            max_tokens=4000,
            system=SNAP_PASS1_SYSTEM,
            messages=[{
                "role": "user",
                "content": f"Clean up this traced SVG. Rewrite using geometric primitives:\n\n{svg_code}{context}"
            }],
        )

        result = response.content[0].text.strip()

        # Strip markdown fences if present
        if result.startswith("```"):
            result = result.split("\n", 1)[1]
            if "```" in result:
                result = result[:result.rfind("```")]
            result = result.strip()

        return result

    def _pass2_visual_refinement(self, svg_code: str, name: str) -> str:
        """Pass 2: Vision + code â€” render screenshot, identify visual issues."""
        import cairosvg

        # Render the Pass 1 SVG to PNG
        render_path = self.output_dir / f"{name}_pass1_render.png"
        cairosvg.svg2png(
            bytestring=svg_code.encode(),
            write_to=str(render_path),
            output_width=512,
            output_height=512,
        )

        # Read and encode the rendered image
        with open(render_path, "rb") as f:
            img_b64 = base64.b64encode(f.read()).decode()

        # Send both SVG code and rendered image to Claude
        response = self.client.messages.create(
            model=self.model,
            max_tokens=4000,
            system=SNAP_PASS2_SYSTEM,
            messages=[{
                "role": "user",
                "content": [
                    {
                        "type": "image",
                        "source": {
                            "type": "base64",
                            "media_type": "image/png",
                            "data": img_b64,
                        }
                    },
                    {
                        "type": "text",
                        "text": (
                            "Here's the rendered SVG above, and the code below. "
                            "Fix any geometric issues you can see:\n\n"
                            f"{svg_code}"
                        ),
                    }
                ],
            }],
        )

        result = response.content[0].text.strip()
        if result.startswith("```"):
            result = result.split("\n", 1)[1]
            if "```" in result:
                result = result[:result.rfind("```")]
            result = result.strip()

        return result

    def _count_nodes(self, svg_code: str) -> int:
        """Count approximate node/element count in SVG."""
        count = 0
        # Count path commands
        import re
        # Count individual path d commands
        paths = re.findall(r'd="([^"]*)"', svg_code)
        for d in paths:
            # Count M, L, C, S, Q, A, Z commands (case insensitive)
            count += len(re.findall(r'[MLCSQAZmlcsqaz]', d))
        # Count primitive elements
        for elem in ['circle', 'rect', 'ellipse', 'line', 'polygon', 'polyline']:
            count += svg_code.count(f'<{elem}')
        return max(count, 1)

    def _detect_primitives(self, svg_code: str) -> list[str]:
        """Detect which SVG primitive types are used."""
        primitives = []
        for elem in ['circle', 'rect', 'ellipse', 'line', 'polygon', 'polyline', 'path']:
            if f'<{elem}' in svg_code:
                primitives.append(elem)
        return primitives

    def clean_batch(self, svg_paths: list[Path],
                    project_name: str = "logo",
                    visual_pass: bool = False) -> list[SnapResult]:
        """Clean multiple SVGs."""
        results = []
        for i, path in enumerate(svg_paths):
            name = f"{project_name}_{i+1}"
            print(f"  ðŸ§¹ Cleaning {i+1}/{len(svg_paths)}: {path.name}")
            result = self.clean(path, name=name, visual_pass=visual_pass)
            print(f"    Nodes: {result.input_nodes} â†’ {result.output_nodes} "
                  f"({result.node_reduction_pct}% reduction)")
            print(f"    Size: {result.input_size_bytes:,}B â†’ {result.output_size_bytes:,}B "
                  f"({result.size_reduction_pct}% reduction)")
            print(f"    Primitives: {', '.join(result.primitives_used)}")
            results.append(result)
        return results
